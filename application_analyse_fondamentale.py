# -*- coding: utf-8 -*-
"""Application Analyse fondamentale.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Djt2o2IHC5Hv-QOkLiuFVzRadWfQ93tb
"""

import datetime
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
import warnings
import sys
import os


# Option 2: Rediriger la sortie d'erreur de yfinance
# Permet d'éviter les messages d'erreur de yfinance dans la console
# pour les tickers invalides, tout en gardant tes propres messages.
original_stderr = sys.stderr
sys.stderr = open(os.devnull, 'w')

def calculate_performance_metrics(symbol: str, years: int) -> tuple[float, float, float]:
    """
    Calcule la performance totale, la performance annualisée moyenne (géométrique)
    et le R-carré (linéarité) d'un symbole boursier sur une période donnée.

    Args:
        symbol (str): Le symbole boursier (ticker).
        years (int): Le nombre d'années sur lequel calculer la performance.

    Returns:
        tuple[float, float, float]: Un tuple contenant :
                                     - La performance totale en pourcentage.
                                     - La performance annualisée moyenne en pourcentage.
                                     - Le R-carré.
                                   Retourne (NaN, NaN, NaN) si les données
                                   ne peuvent pas être récupérées ou si la régression
                                   est impossible.
    """
    today = datetime.date.today()
    start_date = today.replace(year=today.year - years)

    data = yf.download(
        symbol,
        start=start_date.isoformat(),
        end=(today + datetime.timedelta(days=1)).isoformat(),
        progress=False,
        actions=True,
        auto_adjust=False
    )

    if data.empty or len(data) < 2:
        print(f"Attention : Données insuffisantes pour le symbole '{symbol}' sur {years} ans.")
        return float('nan'), float('nan'), float('nan')

    # Calcul de la performance totale (avec dividendes réinvestis)
    p0 = float(data["Adj Close"].iloc[0])
    p1 = float(data["Adj Close"].iloc[-1])
    total_div = float(data["Dividends"].sum())

    # La performance totale est la somme du gain en capital et des dividendes, divisée par le prix initial.
    # On ajoute 1 au rendement pour le calcul géométrique, puis on l'annualise.
    total_return_factor = (p1 - p0 + total_div) / p0 + 1 # Facteur de rendement total (ex: 1.77 pour 77% de gain)

    # Calcul de la performance annualisée moyenne (géométrique)
    # Gère le cas où total_return_factor pourrait être négatif ou zéro (perte totale),
    # auquel cas l'annualisation géométrique n'est pas applicable ou donne un NaN.
    if total_return_factor <= 0:
        annualized_performance = float('nan')
    else:
        # Pour le calcul annualisé, on divise par le nombre exact d'années couvertes par les données
        # pour une meilleure précision.
        # Calcule le nombre d'années réelles couvertes par les données
        actual_years_covered = (data.index[-1] - data.index[0]).days / 365.25
        if actual_years_covered <= 0: # Évite la division par zéro ou racine invalide
            annualized_performance = float('nan')
        else:
            annualized_performance = (total_return_factor**(1/actual_years_covered) - 1) * 100

    rounded_annualized_performance = round(annualized_performance, 2)
    rounded_total_performance = round((total_return_factor - 1) * 100, 2) # Pour garder la performance totale aussi

    # Calcul du R-carré pour la linéarité du prix de clôture ajusté
    X = np.arange(len(data)).reshape(-1, 1)
    y = data["Adj Close"].values.reshape(-1, 1)

    if np.all(y == y[0]):
        print(f"Attention : Prix de clôture constant pour le symbole '{symbol}' sur {years} ans. R-carré non calculable.")
        return rounded_total_performance, rounded_annualized_performance, float('nan')

    try:
        model = LinearRegression()
        model.fit(X, y)
        y_pred = model.predict(X)
        r_squared = r2_score(y, y_pred)
        rounded_r_squared = round(r_squared, 4)
    except Exception as e:
        print(f"Erreur lors du calcul du R-carré pour '{symbol}' sur {years} ans: {e}")
        rounded_r_squared = float('nan')

    return rounded_total_performance, rounded_annualized_performance, rounded_r_squared

# Liste des tickers à analyser.
tickers = [
    "AMZN", "ASML", "NVDA", "GOOG", "BKNG", "NEM.HA", # NEM.HA a été remis comme dans ton code original
    "CRM", "INTU", "MA", "MSFT", "SPGI", "V", "SNY", "IONQ", "AAPL", "TSLA", "JNJ"
]

# --- Calculer les métriques pour 10 ans et 5 ans ---
rows = []
for sym in tickers:
    # Pour 10 ans
    try:
        total_ret_10y, avg_annual_ret_10y, r2_10y = calculate_performance_metrics(sym, 10)
    except Exception as e:
        print(f"Une erreur inattendue s'est produite lors du traitement de '{sym}' sur 10 ans: {e}")
        total_ret_10y, avg_annual_ret_10y, r2_10y = float('nan'), float('nan'), float('nan')

    # Pour 5 ans (seulement la performance annualisée)
    try:
        _, avg_annual_ret_5y, _ = calculate_performance_metrics(sym, 5) # On ignore le total_ret et le R² de 5 ans
    except Exception as e:
        print(f"Une erreur inattendue s'est produite lors du traitement de '{sym}' sur 5 ans: {e}")
        avg_annual_ret_5y = float('nan')

    rows.append([sym, avg_annual_ret_10y, r2_10y, avg_annual_ret_5y])

# Crée un DataFrame pandas avec les colonnes désirées
df = pd.DataFrame(rows, columns=[
    "ticker",
    "10y_avg_annual_return_%", "10y_R2",
    "5y_avg_annual_return_%"
])

# Restaurer la sortie d'erreur originale de sys
sys.stderr.close()
sys.stderr = original_stderr

#dépenses en SBC, % du free cash flow


rows = []
for symbol in tickers:
    t = yf.Ticker(symbol)
    cf = t.cashflow

    # On vérifie que les deux lignes existent
    if 'Stock Based Compensation' in cf.index and 'Free Cash Flow' in cf.index:
        latest_sbc = cf.loc['Stock Based Compensation'].iloc[0]
        latest_fcf = cf.loc['Free Cash Flow'].iloc[0]
        # Calcul du ratio
        ratio = (latest_sbc / latest_fcf) * 100 if latest_fcf else None
    else:
        latest_sbc = latest_fcf = ratio = None

    rows.append({
        "ticker": symbol,
        "SBC_as_%_of_FCF": round(ratio, 2) if ratio is not None else None
    })

df_sbc_fcf = pd.DataFrame(rows)

df = pd.merge(df, df_sbc_fcf, on='ticker')


df

# Initialize a list to store the net debt to EBITDA ratio for each ticker
net_debt_to_ebitda_ratios = []

for symbol in tickers:
    try:
        t = yf.Ticker(symbol)
        info = t.info
        # Extraction des valeurs nécessaires
        total_debt = info.get("totalDebt")
        total_cash = info.get("totalCash")
        ebitda = info.get("ebitda")

        # Calcul de la dette nette et du ratio dette nette / EBITDA
        if total_debt is not None and total_cash is not None and ebitda:
            net_debt = total_debt - total_cash
            net_debt_to_ebitda = net_debt / ebitda
            net_debt_to_ebitda_ratios.append(net_debt_to_ebitda)
        else:
            net_debt_to_ebitda_ratios.append(None)
    except Exception as e:
        print(f"Could not retrieve info for {symbol}: {e}")
        net_debt_to_ebitda_ratios.append(None)

# Add the new data as a column to the DataFrame
df['net_debt_to_ebitda'] = net_debt_to_ebitda_ratios

df

import time
import requests
import pandas as pd

# Ta clé API Finnhub
api_key = "csiada1r01qpalorrno0csiada1r01qpalorrnog"
headers = {"X-Finnhub-Token": api_key}

# Liste des tickers à analyser
tickers = ["AMZN", "ASML", "NVDA", "GOOG", "BKNG", "NEM.HA",
           "CRM", "INTU", "MA", "MSFT", "SPGI", "V", "SNY", "IONQ", "AAPL", "TSLA","JNJ"]

# 1) Un seul dict pour stocker TOUTES les métriques par ticker
all_metrics = {}

for symbol in tickers:
    resp = requests.get(
        "https://finnhub.io/api/v1/stock/metric",
        headers=headers,
        params={"symbol": symbol, "metric": "all"}
    )
    if resp.status_code == 200:
        payload = resp.json().get("metric", {})
        all_metrics[symbol] = payload
    else:
        all_metrics[symbol] = {}
    time.sleep(0.5)  # petit délai pour éviter le throttling

# 2) Créer un nouveau DataFrame pour les métriques Finnhub
finnhub_rows = []
for ticker in tickers:
    metrics = all_metrics.get(ticker, {})
    finnhub_rows.append({
        'ticker': ticker,
        'Revenue_Growth_5Y': metrics.get("revenueGrowth5Y"),
        'Revenue_Growth_LastYear_%': metrics.get("revenueGrowthTTMYoy"),
        'FreeCashFlow5Y': metrics.get("focfCagr5Y"),
        'EPS_Growth_5Y': metrics.get("epsGrowth5Y"),
        'EPS_Growth_3Y': metrics.get("epsGrowth3Y"),
        'ROIC_5Y': metrics.get("roi5Y"),
        'ROI_ANNUAL': metrics.get("roiAnnual"),
        'Gross_Margin_5Y': metrics.get("grossMargin5Y"),
        'Gross_Margin_Annual': metrics.get("grossMarginAnnual")
    })

df_finnhub = pd.DataFrame(finnhub_rows)


# 3) Fusionner avec le DataFrame existant
df = pd.merge(df, df_finnhub, on='ticker')


# 4) (Optionnel) arrondir les colonnes %
for col in [
    'Revenue_Growth_5Y',
    'Revenue_Growth_LastYear_%',
    'FreeCashFlow5Y',
    'EPS_Growth_5Y',
    'EPS_Growth_3Y',
    'ROIC_5Y',
    'ROI_ANNUAL',
    'Gross_Margin_5Y',
    'Gross_Margin_Annual',
    'SBC_as_%_of_FCF'
]:
    # On vérifie si la colonne existe avant de l'arrondir
    if col in df.columns:
        df[col] = df[col].round(2)

# 5) Vérification
print(df)

missing = [t for t,payload in all_metrics.items() if not payload]
print("⚠️ Symboles sans métriques Finnhub:", missing)

df

# Création d'un nouveau dataframe pour les scores
df_score = df[['ticker']].copy()

def calculer_linearite_perf10y(r2_10y):
    if r2_10y is None or pd.isnull(r2_10y):
        return None
    try:
        linearite_perf10y_float = float(r2_10y)
        if linearite_perf10y_float >= 0.8:
            return 1.0
        elif linearite_perf10y_float >= 0.6:
            return 0.5
        else:
            return 0.0
    except ValueError:
        # Si la conversion échoue, retourne None
        return None

# Application de la fonction
df_score['Score_Linearite_Perf10y'] = df['10y_R2'].apply(calculer_linearite_perf10y)

def calculer_performance_5y(avg_annual_ret_5y):
    if avg_annual_ret_5y is None or pd.isnull(avg_annual_ret_5y):
        return None
    try:
        performance_5y_float = float(avg_annual_ret_5y)
        if performance_5y_float >= 12.0:
            return 1.0
        elif performance_5y_float >= 8.0:
            return 0.5
        else:
            return 0.0
    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_Performance_5y'] = df['5y_avg_annual_return_%'].apply(calculer_performance_5y)

def calculer_performance_10y(avg_annual_ret_10y):
    if avg_annual_ret_10y is None or pd.isnull(avg_annual_ret_10y):
        return None
    try:
        performance_10y_float = float(avg_annual_ret_10y)
        if performance_10y_float >= 12.0:
            return 1.0
        elif performance_10y_float >= 8.0:
            return 0.5
        else:
            return 0.0
    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_Performance_10y'] = df['10y_avg_annual_return_%'].apply(calculer_performance_10y)

def calculer_revenuegrowth_5y(Revenue_Growth_5Y):
    if Revenue_Growth_5Y is None or pd.isnull(Revenue_Growth_5Y):
        return None
    try:
        revenuegrowth_5y_float = float(Revenue_Growth_5Y)
        if revenuegrowth_5y_float >= 8 :
            return 1.0
        elif revenuegrowth_5y_float >= 5 :
            return 0.5
        else:
            return 0.0
    except ValueError:
        # Si la conversion échoue, retourne None
        return None


df_score['Score_RevenueGrowth_5y'] = df['Revenue_Growth_5Y'].apply(calculer_revenuegrowth_5y)

def calculerSBCofFCF(SBCofFCF):
    if SBCofFCF is None or pd.isnull(SBCofFCF):
        return None
    try:
        SBCofFCF_float = float(SBCofFCF)
        if SBCofFCF_float <10 :
            return 1.0
        elif SBCofFCF_float < 20 :
            return 0.5
        else:
            return 0.0


    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_SBCofFCF'] = df['SBC_as_%_of_FCF'].apply(calculerSBCofFCF)


def calculer_revenueGrowthlastyear(revenue_growth_last_year):
    if revenue_growth_last_year is None or pd.isnull(revenue_growth_last_year):
        return None
    try:
        revenueGrowthlastyear_float = float(revenue_growth_last_year)
        if revenueGrowthlastyear_float >= 8 :
            return 1.0
        elif revenueGrowthlastyear_float >= 5 :
            return 0.5
        else:
            return 0.0

    except ValueError:
        # Si la conversion échoue, retourne None
        return None


df_score['Score_RevenueGrowth_LastYear'] = df['Revenue_Growth_LastYear_%'].apply(calculer_revenueGrowthlastyear)

def calculer_freecashflow5ans(freecashflow5ans):
    if freecashflow5ans is None or pd.isnull(freecashflow5ans):
      return None
    try:
        freecashflow5ans_float = float(freecashflow5ans)
        if freecashflow5ans_float >= 14 :
            return 1.0
        elif freecashflow5ans_float >= 10 :
            return 0.5
        else:
            return 0.0

    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_FreeCashFlow5ans'] = df['FreeCashFlow5Y'].apply(calculer_freecashflow5ans)

def calculer_eps5ans(eps5ans):
    if eps5ans is None or pd.isnull(eps5ans):
      return None
    try:
        eps5ans_float = float(eps5ans)
        if eps5ans_float >= 12 :
            return 1.0
        elif eps5ans_float >= 8 :
            return 0.5
        else:
            return 0

    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_EPS5ans'] = df['EPS_Growth_5Y'].apply(calculer_eps5ans)

def calculer_eps3ans(eps3ans):
    if eps3ans is None or pd.isnull(eps3ans):
      return None
    try:
        eps3ans_float = float(eps3ans)
        if eps3ans_float >= 12 :
            return 1.0
        elif eps3ans_float >= 8 :
            return 0.5
        else:
            return 0

    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_EPS3ans'] = df['EPS_Growth_3Y'].apply(calculer_eps3ans)


def calculer_roi5ans(roi5ans):
    if roi5ans is None or pd.isnull(roi5ans):
      return None
    try:
        roi5ans_float = float(roi5ans)
        if roi5ans_float >= 15 :
            return 1.0
        elif roi5ans_float >= 10 :
            return 0.5
        else:
            return 0

    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_ROI5ans'] = df['ROIC_5Y'].apply(calculer_roi5ans)


def calculer_roiannual(roiannual):
    if roiannual is None or pd.isnull(roiannual):
      return None
    try:
        roiannual_float = float(roiannual)
        if roiannual_float >= 15 :
            return 1.0
        elif roiannual_float >= 10 :
            return 0.5
        else:
            return 0
    except ValueError:
        # Si la conversion échoue, retourne None
        return None
df_score['Score_ROIANNUAL'] = df['ROI_ANNUAL'].apply(calculer_roiannual)

def calculergrossmargin5y(grossmargin5y):
    if grossmargin5y is None or pd.isnull(grossmargin5y):
      return None
    try:
        grossmargin5y_float = float(grossmargin5y)
        if grossmargin5y_float >= 20 :
            return 1.0
        elif grossmargin5y_float >= 10 :
            return 0.5
        else:
            return 0
            # Si la conversion échoue, retourne None
    except ValueError:
        return None

df_score['Score_GrossMargin5y'] = df['Gross_Margin_5Y'].apply(calculergrossmargin5y)

def calculergrossmargingannual(grossmargingannual):
    if grossmargingannual is None or pd.isnull(grossmargingannual):
      return None
    try:
        grossmargingannual_float = float(grossmargingannual)
        if grossmargingannual_float >= 20 :
            return 1.0
        elif grossmargingannual_float >= 10 :
            return 0.5
        else:
            return 0
            # Si la conversion échoue, retourne None
    except ValueError:
        return None

df_score['Score_GrossMarginAnnual'] = df['Gross_Margin_Annual'].apply(calculergrossmargingannual)

def calculer_net_debt_to_ebitda(net_debt_to_ebitda):
    if net_debt_to_ebitda is None or pd.isnull(net_debt_to_ebitda):
        return None
    try:
        net_debt_to_ebitda_float = float(net_debt_to_ebitda)
        if net_debt_to_ebitda_float < 1 :
            return 1.0
        elif net_debt_to_ebitda_float < 3 :
            return 0.5
        else :
            return 0.0

    except ValueError:
        # Si la conversion échoue, retourne None
        return None

df_score['Score_Net_Debt_to_EBITDA'] = df['net_debt_to_ebitda'].apply(calculer_net_debt_to_ebitda)

df_score

# On somme toutes les colonnes à partir de la 2ᵉ (index 1) ligne par ligne
cols_scores = [col for col in df_score.columns if col != 'ticker']
df_score[cols_scores] = df_score[cols_scores].apply(pd.to_numeric, errors='coerce')
df_score['Total_Score'] = df_score.iloc[:, 1:].sum(axis=1)

## trier de haut en bas, par note de la plus haute à la plus basse
df_score_sorted = df_score.sort_values(by='Total_Score',ascending=False)


# Affichage pour vérifier
print(df_score_sorted)

# Total score pondéré
# On calcule le nombre de critères valides (non-NA) pour chaque ligne
df_score['Valid_Criteria_Count'] = df_score[cols_scores].notna().sum(axis=1)

# Le maximum de points possible par critère est 1 (d'après ton notebook)
max_points_per_criterion = 1

# On calcule le maximum théorique atteignable selon le nombre de critères valides
df_score['Max_Theoretical_Score'] = df_score['Valid_Criteria_Count'] * max_points_per_criterion

# On ajuste maintenant la note sur 20 en fonction du ratio score obtenu / score maximum théorique
df_score['Score_sur_20'] = (df_score['Total_Score'] / df_score['Max_Theoretical_Score']) * 20

# On arrondit la note à deux décimales pour une meilleure lisibilité
df_score['Score_sur_20'] = df_score['Score_sur_20'].round(2)

# On trie à nouveau par la note ajustée sur 20
df_score_sorted = df_score.sort_values(by='Score_sur_20', ascending=False)

# Affichage final pour vérifier
print(df_score_sorted[['ticker', 'Total_Score', 'Score_sur_20']])

def main():
    import datetime
    import os

    # Ton code doit être remonté ici (tout le code depuis les calculs est déjà exécuté au-dessus)
    # Donc ici, on ne refait pas les calculs — on fait uniquement l’export

    today_str = datetime.datetime.today().strftime("%Y-%m-%d")
    df_export = df_score_sorted[['ticker', 'Total_Score', 'Score_sur_20']].copy()
    df_export['date'] = today_str

    # Pour forcer un changement (même si scores identiques)
    df_export['horodatage'] = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    csv_path = "historique_scores.csv"

    if os.path.exists(csv_path):
        df_old = pd.read_csv(csv_path)
        df_combined = pd.concat([df_old, df_export], ignore_index=True)
        df_combined.to_csv(csv_path, index=False)
        print("✅ Fichier historique mis à jour avec succès.")
        print(df_combined.tail().to_string(index=False))
    else:
        df_export.to_csv(csv_path, index=False)
        print("📁 Fichier historique créé pour la première fois.")
        print(df_export.to_string(index=False))


if __name__ == "__main__":
    try:
        main()
        print("✅ Script terminé avec succès.")
    except Exception as e:
        print(f"❌ Une erreur est survenue : {e}")
        import sys
        sys.exit(0)
